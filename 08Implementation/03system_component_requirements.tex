\subsection{Requirements of system components}

//INTRO?

\subsubsection{Application front end}
The front end part of the proposed system has the task of receiving user's input and presenting the progress of a deployed transaction. It communicates directly with the node in order to deploy smart contracts and receive account balance and transaction hashes. Application receives data from the user (such as transaction value or destination address), verifies their validity and prepares the data in a format that can be consumed by the node. Front end also contacts the node and presents eventual replies to the user in an user-comprehensible format. If a reply is not received, the application needs to notify the user too.

\begin{figure}[ht]
    \begin{tabularx}{\textwidth}{|l X|}
    \hline
        \multicolumn{2}{|c|}{\textbf{Application front end}}\\
        \multicolumn{2}{|l|}{\textbf{Functional requirements}}\\
        AF-FR-1&Application must deploy the smart contract to an Ethereum node.\\
        AF-FR-2&Application must be able to query the node for address balance.\\
        AF-FR-3&Application must display the status of the transaction.\\
        &\\
        \multicolumn{2}{|l|}{\textbf{Non-functional requirements}}\\
        AF-NFR-1&Transaction must be signed on device.\\
        AF-NFR-2&Sensitive details about users' funds must not leave the device.\\
    \hline
    \end{tabularx}
   
    \caption{Functional and non-functional requirements on the application front end.}
    \label{fig:reqa-applicaion}
\end{figure}

\subsubsection{Ethereum Node}
Ethereum node plays vital role in the application, as it deploys smart contracts, created by the user to the Ethereum network. If a node fails to do that, users cannot use the application for its purpose. We can say that the role of the node is \textit{business critical}. Table~\ref{fig:reqs-node} lists the reuirements for the Ethereum node.

The node needs to send transactions to the Ethereum network reliably and without delay. When queried, it must provide accurate and most up-to-date response. We can refer to these goals as trustworthiness and reliability. Since it is impossible to guarantee trustworthiness and reliability of any single node controlled by a third party, it would be in user’s best interest to operate their own node. However, operating a full node requires resources which may not be available on a mobile device.

In a such case, where conditions do not allow for operation of a full node, the second-best alternative is to query multiple nodes with the same request and accept the most common answer as the correct one. Since it is safe to suppose that majority of the nodes in the network are honest nodes, this would prevent single malicious node from affecting or halting the transaction process and would also resolve problems caused by downtime of any particular node. While this architecture certainly can be achieved, it is complex to fully implement such a scheme. 

\begin{figure}[ht]
    \centering
    \begin{tabularx}{\textwidth}{|l X|}
        \hline
        \multicolumn{2}{|c|}{\textbf{Ethereum node}}\\
        \multicolumn{2}{|l|}{\textbf{Functional requirements}}\\
        EN-FR-1&Node must support at least the following methods of the JSON-RPC protocol: \texttt{eth\_getBalance} and \texttt{eth\_sendTransaction}.\\
        &\\
        \multicolumn{2}{|l|}{\textbf{Non-functional requirements*}}\\
        EN-NFR-1&Node should process method calls without delay.\\
        EN-NFR-2&Node should process all method calls with equal priority.\\
        EN-NFR-3&Node should inform the application about the outcome of the method call.\\
        \hline
    \end{tabularx}
    \caption{Requirements on the Ethereum node. Note, that it may not be possible to enforce the non-functional requirements.}
    \label{fig:reqs-node}
\end{figure}

The consequences of nodes not fulfilling the functional requirements would be the impossibility to retrieve wallet balance, but more importantly, the impossibility to deploy smart contracts to the network. The latter would result in users not being able to use the application. Since the transaction for contract deployment is singed on user’s device, the node cannot alter transactions it receives. If user deployed a contract, but the node refused to provide transaction hash of this transaction, user’s trading partner would never transfer the second currency. The user would therefore waste funds on paying for the gas for the contract deployment, but would not lose funds as these would be transferred back after the contract timeout period has elapsed. //EXPLAIN ABOUT THIS/REFER TO EXPLANATION

\subsubsection{Smart contract}
A smart contract is deployed to the Ethereum network when the primary and secondary users agreed on a transaction. The contract is deployed by the primary user, who also carries fees necessary for the contract deployment and costs associated with services of the oracle\footnotemark.
% 
\footnotetext{We do not see this as an issue, since the increased costs of the primary user can be estimated beforehand and accounted for when agreeing on the transaction amount. Further analysis of this problem follows in Discussion chapter //Remember to add reference.}

The smart contract must implement the logic of the half black-box (described in Figure~\ref{fig:simple-logic} on page \pageref{fig:simple-logic}. Furthermore, the contract must emit an event after it has been created as it is necessary for the secondary user to verify that the contract was deployed as agreed. For its correct execution, it must also cater for any costs required to cover the services of an oracle.

Optionally, the contract can also emit an event when it receives a response from the oracle. If a transaction was not completed, such event could help users understand the reason. Contracts should also be as short as possible to keep the costs of deployment and operation of the contract to minimum, as the user needs to pay for gas for every bytecode instruction. High prices of operating a contract could deter users from using the application. The requirements on the smart contract are listed in Table~\ref{tab:reqs-smart-contract}.

\begin{table}[ht]
    \centering
    \begin{tabularx}{\textwidth}{|l X|}
    \hline
        \multicolumn{2}{|c|}{\textbf{Smart contract}}\\
        \multicolumn{2}{|l|}{\textbf{Functional requirements}}\\
        SC-FR-1&The smart contract must implement the logic described in~\ref{fig:simple-logic}.\\
        &\\
        \multicolumn{2}{|l|}{\textbf{Non-functional requirements}}\\
        SC-NFR-1&The smart contract must emit en event after contract creation.\\
        SC-NFR-2&The smart contract must cover the costs for the services of the oracle.\\
        SC-NFR-3&The smart contract could emit an event upon receiving a response from the oracle.\\
    \hline
    \end{tabularx}
    \caption{Requirements on the smart contract. Primary user deploys a new smart contract with each transaction.}
    \label{tab:reqs-smart-contract}
\end{table}

\subsubsection{Oracle}

The goal of an oracle is to allow smart contracts access real-world data from inside the Ethereum blockchain. The oracle receives a query from the smart contract, containing a Bitcoin address to look up and at least one web \acrshort{api} endpoint (a blockchain explorer provider) to use for the look-up. It queries this \acrshort{api} and returns the amount of Satoshi at the queried address.

By having a direct influence on whether the Ether will be released by the smart contract, the oracle could prevent any transaction from happening, should it provide incorrect information the smart contract. Naturally, the oracle should provide accurate responses to queries, should not tamper with the results it receives from the blockchain explorer and should treat all queries equally. However, we can not ensure that these requirements are fulfilled. According to requirement PT-NFR-2 (Figure \ref{tab:pt-nonfunc-reqs} on page \pageref{tab:pt-nonfunc-reqs}), there should not be a single point of failure in the system. Multiple oracles should be queried and the most common response should be accepted by the contract as the correct one, to secure the system against an dishonest oracle. However, this may significantly increase the costs of the transaction. Alternative solution would be to implement a response integrity proof, which would verify that the response has not been changed by the oracle. Functional and non-functional requirements on the oracle are listed in Table~\ref{tab:reqs-oracle}.

\begin{table}[ht]
    \centering
    \begin{tabularx}{\textwidth}{|l X|}
    \hline
        \multicolumn{2}{|c|}{\textbf{Oracle}}\\
        \multicolumn{2}{|l|}{\textbf{Functional requirements}}\\
        OR-FR-1&The oracle must support queries to a web \acrshort{api}.\\
        &\\
        \multicolumn{2}{|l|}{\textbf{Non-functional requirements}}\\
        OR-NFR-1&The oracle should provide accurate and correct response to the query.\\
        OR-NFR-2&The oracle should respond to queries without delay (unless otherwise specified).\\
        OR-NFR-3&The oracle should process all queries with equal priority.\\
    \hline
    \end{tabularx}
    \caption{Requirements on the oracle. Note, that it may not be possible to enforce the non-functional requirements and another solution may need to be implemented to avoid centralisation of the system.}
    \label{tab:reqs-oracle}
\end{table}

\subsubsection{Blockchain explorer}

Why do we need this? what do we need *from* this

\subsubsection{Database}

What do we need the database for? Users' communication channel. Not THAT important. Nice to have in prototype